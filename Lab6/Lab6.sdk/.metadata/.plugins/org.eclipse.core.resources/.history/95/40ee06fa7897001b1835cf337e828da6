#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xbram.h"
#include "led_matrix.h"
#include "sprites.h"
#include "sleep.h"
#include "xadcps.h"

/************************** Constant Definitions *****************************/

/*
 * The following constants map to the XPAR parameters created in the
 * xparameters.h file. They are defined here such that a user can easily
 * change all the needed parameters in one place.
 */
#define BRAM_DEVICE_ID		XPAR_BRAM_0_DEVICE_ID
#define XADC_DEVICE_ID		XPAR_PS7_XADC_0_DEVICE_ID

/************************** Struct Definitions *******************************/


/************************** Function Prototypes ******************************/


/************************** Variable Definitions *****************************/
XAdcPs XAdc;
XAdcPs_Config *XAdcConfigPtr;

// Main function for LED matrix
int main(void)
{
	int status;

	status = initLedMatrix(BRAM_DEVICE_ID);
	if (status != XST_SUCCESS) {
		xil_printf("LED matrix initialization failed.");
		while(1);
	}

	XAdcConfigPtr = XAdcPs_LookupConfig(XADC_DEVICE_ID);
	if (XAdcConfigPtr == (XAdcPs_Config *) NULL) {
		xil_printf("XADC Config lookup failed");
		while(1);
	}

	// Initialize XADC from configuration
	status = XAdcPs_CfgInitialize(&XAdc, XAdcConfigPtr, XAdcConfigPtr->BaseAddress);
	if (status != XST_SUCCESS) {
		xil_printf("XADC Initialization failed");
		while(1);
	}

	// Do selftest of BRAM module to check that it's functional
	status = XAdcPs_SelfTest(&XAdc);
	if (status != XST_SUCCESS) {
		xil_printf("XADC Selftest failed");
		while(1);
	}

	// Running LED example
	/*
	while(1) {
		for (int i = 1; i < 9; i++) {
			for (int j = 1; j < 9; j++) {
				if (j > 1) { resetPixelValue(j-1, i); }
				else if (j == 1 && i > 1) { resetPixelValue(8,i-1); }
				writePixelValueDirect(j, i, 255, 0, 0);
				usleep(100000);
			}
		}
		resetPixelValue(8,8);
	}
	*/

	// Fading dots example
	/*
	u8 iterations = 0;
	while(1) {
		for (int i = 1; i < 9; i++) {
			for (int j = 1; j < 9; j++) {
				u8 curr_red, curr_green, curr_blue;
				getPixelValue(i, j, &curr_red, &curr_green, &curr_blue);
				if (curr_red > 9 && curr_green > 9 && curr_blue > 9) {
					setPixelValue(i, j, curr_red-3, curr_green-3, curr_blue-3);
				} else if (curr_red > 9 && curr_green > 9) {
					setPixelValue(i, j, curr_red-3, curr_green-3, 0);
				} else if (curr_red > 9 && curr_blue > 9) {
					setPixelValue(i, j, curr_red-3, 0, curr_blue-3);
				} else if (curr_red > 9) {
					setPixelValue(i, j, curr_red-3, 0, 0);
				} else if (curr_green > 9 && curr_blue > 9) {
					setPixelValue(i, j, 0, curr_green-3, curr_blue-3);
				} else if (curr_green > 9) {
					setPixelValue(i, j, 0, curr_green-3, 0);
				} else if (curr_blue > 9) {
					setPixelValue(i, j, 0, 0, curr_blue-3);
				} else {
					setPixelValue(i, j, 0, 0, 0);
				}
			}
		}

		if (iterations++ == 20) {
			u8 i = rand()%8 + 1;
			u8 j = rand()%8 + 1;
			u8 rand_red = rand()%255 + 1;
			u8 rand_green = rand()%255 + 1;
			u8 rand_blue = rand()%255 + 1;
			setPixelValue(i, j, rand_red, rand_green, rand_blue);
			iterations = 0;
		}

		writeAllPixelsToDevice();
		usleep(25000);
	}
	*/

	// Falling lights example
	/*
	while (1) {
		u8 random_column = rand()%8 + 1;
		u8 red = 0, green = 0, blue = 0;
		while (red == 0 && green == 0 && blue == 0) {
			red = rand()%2;
			green = rand()%2;
			blue = rand()%2;
		}
		writePixelValueDirect(random_column, 1, 22*red, 22*green, 22*blue);

		for (int row = 2; row < 10; row++) {
			usleep(50000);
			for (int column = 1; column < 9; column++) {
				if (row == 9) {
					writePixelValueDirect(column, row-1, 0, 0, 0);
				} else {
					if (pixelActiveValue(column, row-1)) {
						copyPixelValue(column, row-1, column, row);
						decreasePixelValue(column, row, 3, 3, 3);
						writePixelValueToDevice(column, row);
						writePixelValueDirect(column, row-1, 0, 0, 0);
					}
				}
			}
		}
	}
	*/

	// Moving sprites example
	cannon_t cannon;
	position_t pos = {4,1};

	for (int row = 1; row < 9; row++) {
		for (int column = 1; column < 9; column++) {
			if (row == 1) {
				writePixelValueDirect(column, row, 0, 255, 0);
			} else {
				writePixelValueDirect(column, row, 0, 0, 255);
			}
		}
	}

	cannon = draw_cannon(pos);

	u8 direction = 0;
	u8 valid_dir = 0;
	u16 adc_data = 0;
	while(1) {
		usleep(250000);
		adc_data = XAdcPs_GetAdcData(&XAdc, XADCPS_CH_AUX_MAX);
		u8 color_level = (adc_data << 4);
		xil_printf("adc_data is: %d\n\r", adc_data);
		xil_printf("color_level is: %d\n\r", color_level);

		for (int row = 1; row < 9; row++) {
			for (int column = 1; column < 9; column++) {
				if (row == 1) {
					writePixelValueDirect(column, row, 0, color_level, 0);
				} else {
					writePixelValueDirect(column, row, 0, 0, color_level);
				}
			}
		}

		if (direction == 0) {
			valid_dir = move_left_cannon(&cannon);
			if (valid_dir == 1) {
				valid_dir = 0;
			} else {
				direction = 1;
			}
		} else {
			valid_dir = move_right_cannon(&cannon);
			if (valid_dir == 1) {
				valid_dir = 0;
			} else {
				direction = 0;
			}
		}
	}


	xil_printf("Successfully ran code.\r\n");
	while(1);
	return XST_SUCCESS;
}
